function hoistNonReactStatics(e,t,o){if("string"!=typeof t){if(objectPrototype){var r=getPrototypeOf(t);r&&r!==objectPrototype&&hoistNonReactStatics(e,r,o)}var n=getOwnPropertyNames(t);getOwnPropertySymbols&&(n=n.concat(getOwnPropertySymbols(t)));for(var s=0;s<n.length;++s){var i=n[s];if(!(REACT_STATICS[i]||KNOWN_STATICS[i]||o&&o[i])){var a=getOwnPropertyDescriptor(t,i);try{defineProperty(e,i,a)}catch(e){}}}return e}return e}function parse(e,t){for(var o,r=[],n=0,s=0,i="",a=t&&t.delimiter||"/",p=t&&t.delimiters||"./",c=!1;null!==(o=PATH_REGEXP.exec(e));){var h=o[0],u=o[1],l=o.index;if(i+=e.slice(s,l),s=l+h.length,u)i+=u[1],c=!0;else{var d="",y=e[s],m=o[2],f=o[3],g=o[4],R=o[5];if(!c&&i.length){var T=i.length-1;p.indexOf(i[T])>-1&&(d=i[T],i=i.slice(0,T))}i&&(r.push(i),i="",c=!1);var P=""!==d&&void 0!==y&&y!==d,b="+"===R||"*"===R,x="?"===R||"*"===R,v=d||a,w=f||g;r.push({name:m||n++,prefix:d,delimiter:v,optional:x,repeat:b,partial:P,pattern:w?escapeGroup(w):"[^"+escapeString(v)+"]+?"})}}return(i||s<e.length)&&r.push(i+e.substr(s)),r}function compile(e,t){return tokensToFunction(parse(e,t))}function tokensToFunction(e){for(var t=new Array(e.length),o=0;o<e.length;o++)"object"==typeof e[o]&&(t[o]=new RegExp("^(?:"+e[o].pattern+")$"));return function(o,r){for(var n="",s=r&&r.encode||encodeURIComponent,i=0;i<e.length;i++){var a=e[i];if("string"!=typeof a){var p,c=o?o[a.name]:void 0;if(Array.isArray(c)){if(!a.repeat)throw new TypeError('Expected "'+a.name+'" to not repeat, but got array');if(0===c.length){if(a.optional)continue;throw new TypeError('Expected "'+a.name+'" to not be empty')}for(var h=0;h<c.length;h++){if(p=s(c[h]),!t[i].test(p))throw new TypeError('Expected all "'+a.name+'" to match "'+a.pattern+'"');n+=(0===h?a.prefix:a.delimiter)+p}}else if("string"!=typeof c&&"number"!=typeof c&&"boolean"!=typeof c){if(!a.optional)throw new TypeError('Expected "'+a.name+'" to be '+(a.repeat?"an array":"a string"));a.partial&&(n+=a.prefix)}else{if(p=s(String(c)),!t[i].test(p))throw new TypeError('Expected "'+a.name+'" to match "'+a.pattern+'", but got "'+p+'"');n+=a.prefix+p}}else n+=a}return n}}function escapeString(e){return e.replace(/([.+*?=^!:${}()[\]|/\\])/g,"\\$1")}function escapeGroup(e){return e.replace(/([=!:$/()])/g,"\\$1")}function flags(e){return e&&e.sensitive?"":"i"}function regexpToRegexp(e,t){if(!t)return e;var o=e.source.match(/\((?!\?)/g);if(o)for(var r=0;r<o.length;r++)t.push({name:r,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,pattern:null});return e}function arrayToRegexp(e,t,o){for(var r=[],n=0;n<e.length;n++)r.push(pathToRegexp(e[n],t,o).source);return new RegExp("(?:"+r.join("|")+")",flags(o))}function stringToRegexp(e,t,o){return tokensToRegExp(parse(e,o),t,o)}function tokensToRegExp(e,t,o){for(var r=(o=o||{}).strict,n=!1!==o.end,s=escapeString(o.delimiter||"/"),i=[].concat(o.endsWith||[]).map(escapeString).concat("$").join("|"),a="",p=0;p<e.length;p++){var c=e[p];if("string"==typeof c)a+=escapeString(c);else{var h=escapeString(c.prefix),u="(?:"+c.pattern+")";t&&t.push(c),c.repeat&&(u+="(?:"+h+u+")*"),a+=u=c.optional?c.partial?h+"("+u+")?":"(?:"+h+"("+u+"))?":h+"("+u+")"}}return n?(r||(a+="(?:"+s+")?"),a+="$"===i?"$":"(?="+i+")"):(r||(a+="(?:"+s+"(?="+i+"))?"),a+="(?="+s+"|"+i+")"),new RegExp("^"+a,flags(o))}function pathToRegexp(e,t,o){return e instanceof RegExp?regexpToRegexp(e,t):Array.isArray(e)?arrayToRegexp(e,t,o):stringToRegexp(e,t,o)}import React from "./react.js";import PropTypes from "./prop-types.js";const rce=React.createElement;import{createMemoryHistory,createBrowserHistory,addLeadingSlash,createPath,parsePath,createLocation,locationsAreEqual,createHashHistory}from "./history.js";var REACT_STATICS={childContextTypes:!0,contextTypes:!0,defaultProps:!0,displayName:!0,getDefaultProps:!0,mixins:!0,propTypes:!0,type:!0},KNOWN_STATICS={name:!0,length:!0,prototype:!0,caller:!0,callee:!0,arguments:!0,arity:!0},defineProperty=Object.defineProperty,getOwnPropertyNames=Object.getOwnPropertyNames,getOwnPropertySymbols=Object.getOwnPropertySymbols,getOwnPropertyDescriptor=Object.getOwnPropertyDescriptor,getPrototypeOf=Object.getPrototypeOf,objectPrototype=getPrototypeOf&&getPrototypeOf(Object),PATH_REGEXP=new RegExp(["(\\\\.)","(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?"].join("|"),"g");const warning=function(e,t,o){var r=arguments.length;o=new Array(r>2?r-2:0);for(var n=2;n<r;n++)o[n-2]=arguments[n];if(void 0===t)throw new Error("`warning(condition, format, ...args)` requires a warning message argument");if(t.length<10||/^[s\W]*$/.test(t))throw new Error("The warning format should be able to uniquely identify this warning. Please, use a more descriptive format than: "+t);if(!e){var s=0,i="Warning: "+t.replace(/%s/g,function(){return o[s++]});"undefined"!=typeof console&&console.error(i);try{throw new Error(i)}catch(e){}}},invariant=function(e,t,o,r,n,s,i,a){if(void 0===t)throw new Error("invariant requires an error message argument");if(!e){var p;if(void 0===t)p=new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");else{var c=[o,r,n,s,i,a],h=0;(p=new Error(t.replace(/%s/g,function(){return c[h++]}))).name="Invariant Violation"}throw p.framesToPop=1,p}},patternCache={},cacheLimit=1e4;let cacheCount=0;const compileGenerator=e=>{const t=e,o=patternCache[t]||(patternCache[t]={});if(o[e])return o[e];const r=pathToRegexp.compile(e);return cacheCount<1e4&&(o[e]=r,cacheCount++),r},generatePath=(e="/",t={})=>"/"===e?e:compileGenerator(e)(t),patternCache2={};let cacheCount2=0;const compilePath=(e,t)=>{const o=`${t.end}${t.strict}${t.sensitive}`,r=patternCache2[o]||(patternCache2[o]={});if(r[e])return r[e];const n=[],s={re:pathToRegexp(e,n,t),keys:n};return cacheCount2<1e4&&(r[e]=s,cacheCount2++),s},matchPath=(e,t={})=>{"string"==typeof t&&(t={path:t});const{path:o="/",exact:r=!1,strict:n=!1,sensitive:s=!1}=t,{re:i,keys:a}=compilePath(o,{end:r,strict:n,sensitive:s}),p=i.exec(e);if(!p)return null;const[c,...h]=p,u=e===c;return r&&!u?null:{path:o,url:"/"===o&&""===c?"/":c,isExact:u,params:a.reduce((e,t,o)=>(e[t.name]=h[o],e),{})}},isEmptyChildren=e=>0===React.Children.count(e);class Route extends React.Component{constructor(e,t){super(e,t),this.state={match:this.computeMatch(e,t.router)}}getChildContext(){return{router:{...this.context.router,route:{location:this.props.location||this.context.router.route.location,match:this.state.match}}}}computeMatch({computedMatch:e,location:t,path:o,strict:r,exact:n,sensitive:s},i){if(e)return e;invariant(i,"You should not use <Route> or withRouter() outside a <Router>");const{route:a}=i,p=(t||a.location).pathname;return o?matchPath(p,{path:o,strict:r,exact:n,sensitive:s}):a.match}componentWillMount(){warning(!(this.props.component&&this.props.render),"You should not use <Route component> and <Route render> in the same route; <Route render> will be ignored"),warning(!(this.props.component&&this.props.children&&!isEmptyChildren(this.props.children)),"You should not use <Route component> and <Route children> in the same route; <Route children> will be ignored"),warning(!(this.props.render&&this.props.children&&!isEmptyChildren(this.props.children)),"You should not use <Route render> and <Route children> in the same route; <Route children> will be ignored")}componentWillReceiveProps(e,t){warning(!(e.location&&!this.props.location),'<Route> elements should not change from uncontrolled to controlled (or vice versa). You initially used no "location" prop and then provided one on a subsequent render.'),warning(!(!e.location&&this.props.location),'<Route> elements should not change from controlled to uncontrolled (or vice versa). You provided a "location" prop initially but omitted it on a subsequent render.'),this.setState({match:this.computeMatch(e,t.router)})}render(){const{match:e}=this.state,{children:t,component:o,render:r}=this.props,{history:n,route:s,staticContext:i}=this.context.router,a={match:e,location:this.props.location||s.location,history:n,staticContext:i};return o?e?React.createElement(o,a):null:r?e?r(a):null:"function"==typeof t?t(a):t&&!isEmptyChildren(t)?React.Children.only(t):null}}Route.propTypes={computedMatch:PropTypes.object,path:PropTypes.string,exact:PropTypes.bool,strict:PropTypes.bool,sensitive:PropTypes.bool,component:PropTypes.func,render:PropTypes.func,children:PropTypes.oneOfType([PropTypes.func,PropTypes.node]),location:PropTypes.object},Route.contextTypes={router:PropTypes.shape({history:PropTypes.object.isRequired,route:PropTypes.object.isRequired,staticContext:PropTypes.object})},Route.childContextTypes={router:PropTypes.object.isRequired};class Prompt extends React.Component{enable(e){this.unblock&&this.unblock(),this.unblock=this.context.router.history.block(e)}disable(){this.unblock&&(this.unblock(),this.unblock=null)}componentWillMount(){invariant(this.context.router,"You should not use <Prompt> outside a <Router>"),this.props.when&&this.enable(this.props.message)}componentWillReceiveProps(e){e.when?this.props.when&&this.props.message===e.message||this.enable(e.message):this.disable()}componentWillUnmount(){this.disable()}render(){return null}}Prompt.propTypes={when:PropTypes.bool,message:PropTypes.oneOfType([PropTypes.func,PropTypes.string]).isRequired},Prompt.defaultProps={when:!0},Prompt.contextTypes={router:PropTypes.shape({history:PropTypes.shape({block:PropTypes.func.isRequired}).isRequired}).isRequired};class Redirect extends React.Component{isStatic(){return this.context.router&&this.context.router.staticContext}componentWillMount(){invariant(this.context.router,"You should not use <Redirect> outside a <Router>"),this.isStatic()&&this.perform()}componentDidMount(){this.isStatic()||this.perform()}componentDidUpdate(e){const t=createLocation(e.to),o=createLocation(this.props.to);locationsAreEqual(t,o)?warning(!1,`You tried to redirect to the same route you're currently on: `+`"${o.pathname}${o.search}"`):this.perform()}computeTo({computedMatch:e,to:t}){return e?"string"==typeof t?generatePath(t,e.params):{...t,pathname:generatePath(t.pathname,e.params)}:t}perform(){const{history:e}=this.context.router,{push:t}=this.props,o=this.computeTo(this.props);t?e.push(o):e.replace(o)}render(){return null}}Redirect.propTypes={computedMatch:PropTypes.object,push:PropTypes.bool,from:PropTypes.string,to:PropTypes.oneOfType([PropTypes.string,PropTypes.object]).isRequired},Redirect.defaultProps={push:!1},Redirect.contextTypes={router:PropTypes.shape({history:PropTypes.shape({push:PropTypes.func.isRequired,replace:PropTypes.func.isRequired}).isRequired,staticContext:PropTypes.object}).isRequired};class Router extends React.Component{getChildContext(){return{router:{...this.context.router,history:this.props.history,route:{location:this.props.history.location,match:this.state.match}}}}constructor(e){super(e),this.state={match:this.computeMatch(e.history.location.pathname)}}computeMatch(e){return{path:"/",url:"/",params:{},isExact:"/"===e}}componentWillMount(){const{children:e,history:t}=this.props;invariant(null==e||1===React.Children.count(e),"A <Router> may have only one child element"),this.unlisten=t.listen(()=>{this.setState({match:this.computeMatch(t.location.pathname)})})}componentWillReceiveProps(e){warning(this.props.history===e.history,"You cannot change <Router history>")}componentWillUnmount(){this.unlisten()}render(){const{children:e}=this.props;return e?React.Children.only(e):null}}Router.propTypes={history:PropTypes.object.isRequired,children:PropTypes.node},Router.contextTypes={router:PropTypes.object},Router.childContextTypes={router:PropTypes.object.isRequired};class MemoryRouter extends React.Component{constructor(e){super(e),this.history=this.history.bind(this)}history(){return createMemoryHistory(this.props)}componentWillMount(){warning(!this.props.history,"<MemoryRouter> ignores the history prop. To use a custom history, use `import { Router }` instead of `import { MemoryRouter as Router }`.")}render(){return rce(Router,{history:this.history},this.props.children)}}MemoryRouter.propTypes={initialEntries:PropTypes.array,initialIndex:PropTypes.number,getUserConfirmation:PropTypes.func,keyLength:PropTypes.number,children:PropTypes.node};const normalizeLocation=e=>{const{pathname:t="/",search:o="",hash:r=""}=e;return{pathname:t,search:"?"===o?"":o,hash:"#"===r?"":r}},addBasename=(e,t)=>e?{...t,pathname:addLeadingSlash(e)+t.pathname}:t,stripBasename=(e,t)=>{if(!e)return t;const o=addLeadingSlash(e);return 0!==t.pathname.indexOf(o)?t:{...t,pathname:t.pathname.substr(o.length)}},createStaticLocation=e=>"string"==typeof e?parsePath(e):normalizeLocation(e),createURL=e=>"string"==typeof e?e:createPath(e),staticHandler=e=>()=>{invariant(!1,"You cannot %s with <StaticRouter>",e)},noop=()=>{};class StaticRouter extends React.Component{getChildContext(){return{router:{staticContext:this.props.context}}}constructor(e){super(e),this.createHref=this.createHref.bind(this),this.handlePush=this.handlePush.bind(this),this.handleReplace=this.handleReplace.bind(this),this.handleListen=this.handleListen.bind(this),this.handleBlock=this.handleBlock.bind(this)}createHref(e){return addLeadingSlash(this.props.basename+createURL(e))}handlePush(e){const{basename:t,context:o}=this.props;o.action="PUSH",o.location=addBasename(t,createStaticLocation(e)),o.url=createURL(o.location)}handleReplace(e){const{basename:t,context:o}=this.props;o.action="REPLACE",o.location=addBasename(t,createStaticLocation(e)),o.url=createURL(o.location)}handleListen(){return noop}handleBlock(){return noop}componentWillMount(){warning(!this.props.history,"<StaticRouter> ignores the history prop. To use a custom history, use `import { Router }` instead of `import { StaticRouter as Router }`.")}render(){const{basename:e,context:t,location:o,...r}=this.props,n={createHref:this.createHref,action:"POP",location:stripBasename(e,createStaticLocation(o)),push:this.handlePush,replace:this.handleReplace,go:staticHandler("go"),goBack:staticHandler("goBack"),goForward:staticHandler("goForward"),listen:this.handleListen,block:this.handleBlock};return rce(Router,{history:n,...r})}}StaticRouter.propTypes={basename:PropTypes.string,context:PropTypes.object.isRequired,location:PropTypes.oneOfType([PropTypes.string,PropTypes.object])},StaticRouter.defaultProps={basename:"",location:"/"},StaticRouter.childContextTypes={router:PropTypes.object.isRequired};class Switch extends React.Component{componentWillMount(){invariant(this.context.router,"You should not use <Switch> outside a <Router>")}componentWillReceiveProps(e){warning(!(e.location&&!this.props.location),'<Switch> elements should not change from uncontrolled to controlled (or vice versa). You initially used no "location" prop and then provided one on a subsequent render.'),warning(!(!e.location&&this.props.location),'<Switch> elements should not change from controlled to uncontrolled (or vice versa). You provided a "location" prop initially but omitted it on a subsequent render.')}render(){const{route:e}=this.context.router,{children:t}=this.props,o=this.props.location||e.location;let r,n;return t.forEach(t=>{if(null==r&&React.isValidElement(t)){const{path:s,exact:i,strict:a,sensitive:p,from:c}=t.props?t.props:t.attributes,h=s||c;n=t,r=h?matchPath(o.pathname,{path:h,exact:i,strict:a,sensitive:p}):e.match}}),r?React.cloneElement(n,{location:o,computedMatch:r}):null}}Switch.contextTypes={router:PropTypes.shape({route:PropTypes.object.isRequired}).isRequired},Switch.propTypes={children:PropTypes.node,location:PropTypes.object};const withRouter=e=>{const t=t=>{const{wrappedComponentRef:o,...r}=t;return rce(Route,{render:t=>rce(e,Object.assign({},{...r},{...t},{ref:o}))})};return t.displayName=`withRouter(${e.displayName||e.name})`,t.WrappedComponent=e,t.propTypes={wrappedComponentRef:PropTypes.func},hoistStatics(t,e)};class BrowserRouter extends React.Component{constructor(e){super(e),this.history=this.history.bind(this)}history(){return createBrowserHistory(this.props)}componentWillMount(){warning(!this.props.history,"<BrowserRouter> ignores the history prop. To use a custom history, use `import { Router }` instead of `import { BrowserRouter as Router }`.")}render(){return rce(Router,{history:this.history},this.props.children)}}BrowserRouter.propTypes={basename:PropTypes.string,forceRefresh:PropTypes.bool,getUserConfirmation:PropTypes.func,keyLength:PropTypes.number,children:PropTypes.node};class HashRouter extends React.Component{constructor(e){super(e),this.history=this.history.bind(this)}history(){return createHashHistory(this.props)}componentWillMount(){warning(!this.props.history,"<HashRouter> ignores the history prop. To use a custom history, use `import { Router }` instead of `import { HashRouter as Router }`.")}render(){return rce(Router,{history:this.history},this.props.children)}}HashRouter.propTypes={basename:PropTypes.string,getUserConfirmation:PropTypes.func,hashType:PropTypes.oneOf(["hashbang","noslash","slash"]),children:PropTypes.node};const isModifiedEvent=e=>!!(e.metaKey||e.altKey||e.ctrlKey||e.shiftKey);class Link extends React.Component{constructor(e){super(e),this.handleClick=this.handleClick.bind(this)}handleClick(e){if(this.props.onClick&&this.props.onClick(e),!e.defaultPrevented&&0===e.button&&!this.props.target&&!isModifiedEvent(e)){e.preventDefault();const{history:t}=this.context.router,{replace:o,to:r}=this.props;o?t.replace(r):t.push(r)}}render(){const{replace:e,to:t,innerRef:o,...r}=this.props;invariant(this.context.router,"You should not use <Link> outside a <Router>");const{history:n}=this.context.router,s="string"==typeof t?createLocation(t,null,null,n.location):t,i=n.createHref(s);return rce("a",Object.assign({...r},{onClick:this.handleClick,href:i,ref:o}))}}Link.propTypes={onClick:PropTypes.func,target:PropTypes.string,replace:PropTypes.bool,to:PropTypes.oneOfType([PropTypes.string,PropTypes.object]).isRequired,innerRef:PropTypes.oneOfType([PropTypes.string,PropTypes.func])},Link.defaultProps={replace:!1},Link.contextTypes={router:PropTypes.shape({history:PropTypes.shape({push:PropTypes.func.isRequired,replace:PropTypes.func.isRequired,createHref:PropTypes.func.isRequired}).isRequired}).isRequired};const NavLink=({to:e,exact:t,strict:o,location:r,activeClassName:n,className:s,activeStyle:i,style:a,isActive:p,ariaCurrent:c,...h})=>{const u=("object"==typeof e?e.pathname:e).replace(/([.+*?=^!:${}()[\]|/\\])/g,"\\$1");return rce(Route,{path:u,exact:t,strict:o,location:r},({location:t,match:o})=>{const r=!!(p?p(o,t):o);return rce(Link,{to:e,className:r?[s,n].filter(e=>e).join(" "):s,style:r?{...a,...i}:a,"aria-current":r&&c,...h})})};NavLink.propTypes={to:Link.propTypes.to,exact:PropTypes.bool,strict:PropTypes.bool,location:PropTypes.object,activeClassName:PropTypes.string,className:PropTypes.string,activeStyle:PropTypes.object,style:PropTypes.object,isActive:PropTypes.func,ariaCurrent:PropTypes.oneOf(["page","step","location","true"])},NavLink.defaultProps={activeClassName:"active",ariaCurrent:"true"};const{computeMatch:computeMatch}=Router.prototype,matchRoutes=(e,t,o=[])=>(e.some(e=>{const r=e.path?matchPath(t,e):o.length?o[o.length-1].match:computeMatch(t);return r&&(o.push({route:e,match:r}),e.routes&&matchRoutes(e.routes,t,o)),r}),o),renderRoutes=(e,t={})=>e?rce(Switch,null,e.map((e,o)=>rce(Route,{key:e.key||o,path:e.path,exact:e.exact,strict:e.strict,render:o=>rce(e.component,{...o,...t,route:e})}))):null;export{BrowserRouter,HashRouter,Link,MemoryRouter,NavLink,Prompt,Redirect,Route,Router,StaticRouter,Switch,matchPath,withRouter,matchRoutes,renderRoutes};
